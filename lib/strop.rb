# frozen_string_literal: true

# require "debug"; DEBUGGER__.add_catch_breakpoint "Exception"
require_relative "strop/version"

# Command-line option parser that builds options from help text
module Strop

  # Option declaration: names, argument requirement, and canonical label (auto-determined)
  # Optdecl[:f, :foo, arg: :may] #=> Optdecl(names: ["f", "foo"], arg: :may, label: "foo")
  Optdecl = Data.define(:names, :arg, :label) do
    def self.[](*names, arg: nil) = new(names:, arg:) # Custom builder: Optdecl[names, ..., arg: ...]
    def initialize(names:, arg: nil)
      names = [*names].map{ Symbol === it ? it.to_s.gsub(?_, ?-) : it } # :foo_bar to "foo-bar" for symbols
      names[0] = names[0].sub(/[!?]$/, "") unless arg                   # opt? / opt! to opt, and... (unless arg given)
      arg ||= { ?? => :may, ?! => :must }[$&] || :shant                 # use ?/! to determine arg (unless arg given)
      label = names.find{ it.size > 1 } || names.first                  # the canonical name used to search for it
      %i[must may shant].member? arg or raise "invalid arg"             # validate arg
      super names:, arg:, label:
    end

    def no?  = names.each_cons(2).any?{|a,b| b =~ /\Ano-?#{Regexp.escape a}\z/ } # is a flag like --[no-]foo, --[no]bar
    def arg? = self.arg != :shant # accepts arg
    def arg! = self.arg == :must  # requires arg
    def to_s = names.map{ (it[1] ? "--" : "-")+it }.join(", ") + { must: " X", may: " [X]", shant: "" }[arg]
  end

  # List of option declarations with lookup via #[]. Used by `parse`. Generated by `parse_help`
  # Optlist[decl1, decl2] #=> [Optdecl(...), Optdecl(...)]
  class Optlist < Array # a list of Optdecls
    def self.from_help(doc) = Strop.parse_help(doc) #=> Optlist[decl, ...] # Build from help text
    def [](k, ...) = [String, Symbol].any?{ it === k } ? self.find{ it.names.member? k.to_s } : super(k, ...)
    def to_s(as=:plain)
      case as
      when :plain then join("\n")
      when :case
        caseins = map{|os| "in label: #{os.label.inspect}".tap{ it << ", value:" if os.arg? }}
        len = caseins.map(&:size).max
        caseins = caseins.zip(self).map{ |s,o| s.ljust(len) + " then#{' opt.no?' if o.no?} # #{o}" }
        <<~RUBY
          for item in Strop.parse!(optlist)
            case item
            #{caseins.map{ "  #{it}" }.join("\n").lstrip}
            in arg: then # positional
            in Strop::Sep then break # if you want to handle result.rest separately
            else raise "Unhandled result \#{item}"
            end
          end
        RUBY
      end
    end
  end


  # Positional argument value wrapper. Used internally. Seen as member of Result.
  # Arg[value: "file.txt"] #=> Arg(value: "file.txt", arg: "file.txt") # arg alias for pattern matching
  Arg = Data.define :value, :arg do
    def initialize(value:) = super(value:, arg: value)
    alias to_s value
  end

  # Parsed option with declaration, invocation name, value, and negation state. Used internally. Seen as member of Result.
  # Opt[decl: optdecl, name: "verbose", value: "2"] #=> Opt(decl: ..., name: "verbose", value: "2", label: "verbose", no: false)
  Opt = Data.define :decl, :name, :value, :label, :no do
    def initialize(decl:, name:, value: nil)
      label = decl.label                              # repeated here so can be pattern-matched against in case/in
      no = name =~ /\Ano-?/ && decl.names.member?($') # flag given in negated version: (given --no-foo and also accepts --foo)
      super(decl:, name:, value:, label:, no: !!no)
    end
    alias no? no
    def yes? = !no?
  end

  # Const for parsed `--` end of option markers. Seen as member of Result.
  Sep = :end_marker

  # Parse result containing options, arguments, and separators; Returned by `parse`
  # Result[opt1, arg1, Sep] #=> [Opt(...), Arg(...), Sep]
  class Result < Array # of Opt, Arg, Sep
    def rest = drop_while{ it != Sep }.drop(1) # args after sep
    def args = Result.new(select { Arg === it })
    def opts = Result.new(select { Opt === it })
    def [](k, ...)
      case k
      when String, Symbol then find{ Opt === it && it.decl.names.member?(k.to_s) }
      else super(k, ...)
      end
    end
  end

  class OptionError < ArgumentError; end # Raised during parse, with error msgs

  # Convenience. Include if you don't wanna Strop:: everywhere.
  module Exports
    Optlist     = Optlist
    Optdecl     = Optdecl
    Opt         = Opt
    Arg         = Arg
    Sep         = Sep
    OptionError = OptionError
  end

  # for debugging only, TODO remove later probably
  class Arg
    def encode_with(coder) = (coder.scalar = self.value; coder.tag = nil)
  end
  class Opt
    def encode_with(coder) = (coder.map = { self.name => self.value }; coder.tag = nil)
  end

  # Parse command line arguments array against option declarations. Defaults to parsing ARGV
  # Accepts help text, file object for help file, or Optlist
  def self.parse(optlist, argv=ARGV) #=> Result[...]
    Array === argv && argv.all?{ String === it } or raise "argv must be an array of strings (given #{argv.class})"
    optlist = case optlist
    when IO      then parse_help(optlist.read)
    when String  then parse_help(optlist)
    when Optlist then optlist
    else raise "optlist must be an Optlist or help text (given #{optlist.class})"
    end
    tokens = argv.dup
    res = Result.new
    ctx = :top
    name, token, opt = nil
    rx_value = /\A[^-]|\A\z/ # not an opt
    loop do
      case ctx
      in :end then return res.concat tokens.map{ Arg[it] } # opt parsing ended, rest is positional args
      in :value then ctx = :top; res << Arg[token]         # interspersed positional arg amidst opts

      in :top
        token = tokens.shift or next ctx = :end                           # next token or done
        case token
        in "--"          then ctx = :end; res << Sep                      # end of options
        in /\A--(.+)\z/m then token, ctx = $1, :long                      # long (--foo, --foo xxx), long with attached value (--foo=xxx)
        in /\A-(.+)\z/m  then token, ctx = $1, :short                     # short or clump (-a, -abc)
        in ^rx_value     then ctx = :value                                # value
        end

      in :long
        name, value = *token.split(?=, 2)
        opt = optlist[name] or raise OptionError, "Unknown option: --#{name}"
        case [opt.arg?, value]
        in true,  String then ctx = :top; res << Opt[opt, name, value]    # --foo=XXX
        in false, nil    then ctx = :top; res << Opt[opt, name]           # --foo
        in true,  nil    then ctx = :arg                                  # --foo XXX
        in false, String then raise OptionError, "Option --#{name} takes no argument"
        end

      in :short
        name, token = token[0], token[1..].then{ it if it != "" }         # -abc -> a, bc
        opt = optlist[name] or raise OptionError, "Unknown option: -#{name}"
        case [opt.arg?, token]
        in true,  String then ctx = :top; res << Opt[opt, name, token]    # -aXXX
        in false, nil    then ctx = :top; res << Opt[opt, name]           # end of -abc
        in true,  nil    then ctx = :arg                                  # -a XXX
        in false, String then res << Opt[opt, name]                       # -abc -> took -a, will parse -bc
        end

      in :arg
        token = tokens[0]&.match(rx_value) && tokens.shift
        case [opt.arg, token]
        in :may,  String then ctx = :top; res << Opt[opt, name, token]   # --opt val
        in :must, String then ctx = :top; res << Opt[opt, name, token]   # --req val
        in :may,  nil    then ctx = :top; res << Opt[opt, name]          # --opt followed by --foo, --opt as last token
        in :must, nil    then raise OptionError, "Expected argument for option -#{?- if name[1]}#{name}" # --req missing value
        end

      end
    end
  end

  # Parse with error handling: print message and exit on OptionError
  def self.parse!(...) #=> Result[...]
    parse(...)
  rescue OptionError => e
    $stderr.puts e.message
    exit 1
  end


  RX_SOARG = /\[\S+?\]/                        # short opt optional arg
  RX_SARG  = /[^\s,]+/                         # short opt required arg
  RX_LOARG = /\[=\S+?\]| #{RX_SOARG}/          # long opt optional arg: --foo[=bar] or --foo [bar]
  RX_LARG  = /[ =]#{RX_SARG}/                  # long opt required arg: --foo=bar or --foo bar
  RX_NO    = /\[no-?\]/                        # prefix for --[no-]flags
  RX_SOPT  = /-[^-\s,](?: (?:#{RX_SOARG}|#{RX_SARG}))?/                      # full short opt
  RX_LOPT  = /--(?=[^-=,\s])#{RX_NO}?[^\s=,\[]+(?:#{RX_LOARG}|#{RX_LARG})?/  # full long opt
  RX_OPT   = /#{RX_SOPT}|#{RX_LOPT}/           # either opt
  RX_OPTS  = /#{RX_OPT}(?:, {0,2}#{RX_OPT})*/  # list of opts, comma separated

  # Extract option declarations from formatted help text
  def self.parse_help(help, pad: /(?:  ){1,2}/) #=> Optlist[...]
    decls = help.scan(/^#{pad}(#{RX_OPTS})(.*)/).map do |line, rest| # get all optdecl lines
      # Ambiguous: --opt Desc with only one space before will interpret "Desc" as arg.
      ambiguous = rest =~ /^ \S/ && line =~ / (#{RX_SARG})$/ # desc preceeded by sringle space && last arg is " "+word. Capture arg name for error below
      ambiguous and $stderr.puts "#{$1.inspect} was interpreted as argument, In #{(line+rest).inspect}. Use at least two spaces before description to avoid this warning."
      pairs = line.scan(RX_OPT).map { it.split(/(?=\[=)|=| +/, 2) }                        # take options from each line, separate name from arg
      pairs.map! { |name, arg| [name.sub(/^--?/, ''), arg.nil? ? :shant : arg[0] == "[" ? :may : :must] } # remove opt markers -/--, transform arg str into requirement
      names, args = pairs.transpose                                                        # [[name, arg], ...] -> [names, args]
      arg, *rest = args.uniq.tap{ it.delete :shant if it.size > 1 }                        # delete excess :shant (from -f in -f,--foo=x, without arg on short opt)
      raise "Option #{names} has conflicting arg requirements: #{args}" if rest.any?       # raise if still conflict, like -f X, --ff [X]
      names = (names.flat_map{ it.start_with?(RX_NO) ? [$', $&[1...-1] + $'] : it }).uniq  # expand --[no]flag into --flag and --noflag (also --[no-])
      [names, arg]                                                                         # [names and noflags, resolved single arg]
    end.uniq                                                                               # allow identical opts
    dupes = decls.flat_map(&:first).tally.reject{|k,v|v==1}                                # detect repeated names with diff specs
    raise "Options #{dupes.keys.inspect} seen more than once in distinct definitions" if dupes.any?
    decls.map{ |names, arg| Optdecl[*names, arg:] }.then{ Optlist[*it] }                   # Return an Optlist from decls
  end

end
